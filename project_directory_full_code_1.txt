Aggregated on: 2025-12-30 10:33:21
================================================================================
Project Directory Tree:
/
├── data
│   └── universe.json
├── static
│   ├── images
│   ├── js
│   │   └── blackhole
│   │       ├── input
│   │       │   ├── camera_controls.js
│   │       │   ├── input_state.js
│   │       │   └── ship_controls.js
│   │       ├── phaser
│   │       │   └── phaser_overlay.js
│   │       ├── shared
│   │       │   ├── math.js
│   │       │   ├── physics_height.js
│   │       │   └── resize.js
│   │       ├── three
│   │       │   ├── asteroids.js
│   │       │   ├── grid.js
│   │       │   ├── grid_shader.js
│   │       │   ├── planets.js
│   │       │   ├── ship.js
│   │       │   ├── three_boot.js
│   │       │   └── universe.js
│   │       └── main.js
│   └── json
│       └── tuning.json
├── templates
│   └── index.html
├── .bashrc
├── .gitconfig
├── .gitignore
├── .profile
├── .pythonstartup.py
├── .vimrc
├── _Review_Functions.py
├── flask_app.py
├── general.md
├── project_directory_full_code_1.txt
└── README.txt

11 directories, 29 files
================================================================================

[-] This file: general.md | Contents:
Alien Cargo is a vertical scrolling space shooter (traveling 'up' along the screen).
The ship points North (bottom to top).
View: Top-down with a slight perspective angle to create a 2.5D effect. Think Outrun the racing game perspective, but with a spaceship.
### Coordinates
- **+Z**: Moving Forward (Up the screen)
- **-Z**: Moving Backward (Down the screen)
- **+Y**: Altitude (Distance above the grid surface)
- **-Y**: Descent (Closer to the grid surface)
- **+X/-X**: Lateral movement (Right/Left)
### The Infinite Corridor (Scrolling System)
Since movement is primarily forward (+Z), the world is generated as an **infinite 3-lane corridor**.
- **Lanes**: The universe is strictly tiled into 3 horizontal sectors relative to the ship: Left (-1), Center (0), and Right (1).
- **Generation**: As the ship moves forward in Z, we spawn new rows of these 3 sectors ahead.
- **Garbage Collection**: Strictly cull sectors that fall behind the ship (negative Z relative to ship) to keep memory usage constant.
- **Boundaries**: The ship is confined to this corridor not by hard walls, but by an **exponential repulsion field** (an "invisible magnetic wall") that pushes back harder the further the ship strays from the center.
### The "Liquid" Spacetime Grid
The spacetime grid behaves less like a rigid wireframe and more like a **viscous liquid ocean**.
- **Flow**: The grid texture flows continuously like a river.
- **Gravity Wells**: Planets and Black Holes create deep depressions (dips) in the grid.
- **Whirlpools**: Gravity wells exert a tangential force, creating a **whirlpool effect** where the grid visually spins and flows into the "sink" of the planet/black hole.
- **Waves**: The grid surface undulates with gentle, rolling noise-based waves, and the ship "bobs" on these waves physically.
### Celestial Objects
- **Scale**: Objects are **massive**.
    - **Black Holes**: Huge, screen-spanning whirlpools (Radius ~20-30). They dominate the view and should be spawned slightly off-center so the player can just barely navigate around their event horizon.
    - **Planets**: Large obstacles (Radius ~12-25) that require significant lateral movement to dodge.
- **Satellites**: Planets may have **1-3 orbiting asteroids/moons**. These orbit in a ring around the planet's equator.
- **Asteroids**: Can be smooth or jagged (noise deformed). They orbit locally around planets rather than floating freely in deep space.
### Ship Physics
- **Movement**: Physics-based, using velocity, acceleration, and friction (inertia).
- **Feel**: The ship should feel responsive but have weight. It shouldn't stop instantly (drift).
- **Controls**:
    - **Forward**: Automatic cruise speed with "brake" (Arrow Down) to slow down.
    - **Lateral**: Fast, snappy acceleration (Arrow Left/Right) to dodge the massive obstacles.
================================================================================

[-] This file: static/js/blackhole/input/camera_controls.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
const _desiredPos = new THREE.Vector3();
const _lookAt = new THREE.Vector3();
const _forward = new THREE.Vector3(0, 0, -1);
export function updateChaseCamera(camera, ship, dt) {
  // Ship forward from its yaw
  const shipYaw = ship.mesh.rotation.y - Math.PI / 4;
  const shipForward = _forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), shipYaw);
  // Camera offset behind/above ship in WORLD space
  // [TUNING] Pulled back and up for a wider view
  const camHeight = 18.0; // Was 13.5
  const camBack = 35.0;   // Was 27.5
  _desiredPos.set(
    ship.mesh.position.x,
    ship.mesh.position.y + camHeight,
    ship.mesh.position.z + camBack
  );
  const lookAhead = 100.0;
  _lookAt.copy(ship.mesh.position).addScaledVector(shipForward, lookAhead);
  // Smooth follow
  const follow = 1.0 - Math.pow(0.001, dt);
  camera.position.lerp(_desiredPos, follow);
  camera.lookAt(_lookAt);
}
================================================================================

[-] This file: static/js/blackhole/input/input_state.js | Contents:
export const input = {
  keys: new Set(),
  dragging: false,
  yaw: 0,
  pitch: 0
};
window.addEventListener("keydown", e => input.keys.add(e.code));
window.addEventListener("keyup", e => input.keys.delete(e.code));
================================================================================

[-] This file: static/js/blackhole/input/ship_controls.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { input } from "./input_state.js";
import { getSurfaceHeight } from "../shared/physics_height.js";
const ray = new THREE.Raycaster();
const refPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
const _hit = new THREE.Vector3();
// Fallback defaults
const DEFAULT_CONFIG = {
  baseSpeed: 50,
  brakePower: 80,
  hoverOffset: 4.0,
  maxLateralSpeed: 300,
  lateralAccel: 10.0,
  lateralFriction: 5.0,
  boundaryEdge: 550,      // Distance from center where repulsion starts
  boundaryStrength: 15.0  // Multiplier for the exponential force
};
export function updateShip(ship, camera, renderer, dt, time, activePlanets, config) {
  const conf = config || DEFAULT_CONFIG;
  const w = renderer.domElement.clientWidth;
  const h = renderer.domElement.clientHeight;
  // Center Screen Reference
  const cx = w / 2;
  const by = h - ship.state.boxBottom;
  if (ship.state.cursorX === undefined) ship.state.cursorX = cx;
  if (ship.state.cursorY === undefined) ship.state.cursorY = by - ship.state.boxHeight * 0.35;
  if (ship.state.velX === undefined) ship.state.velX = 0;
  // --- 1. FORWARD MOVEMENT ---
  let targetForward = conf.baseSpeed;
  if (input.keys.has("ArrowDown")) {
    ship.state.speedPx -= conf.brakePower * dt;
    if (ship.state.speedPx < 0) ship.state.speedPx = 0;
  } else {
    const diff = targetForward - ship.state.speedPx;
    ship.state.speedPx += diff * 2.0 * dt;
  }
  // --- 2. LATERAL MOVEMENT ---
  let dirX = 0;
  if (input.keys.has("ArrowLeft")) dirX -= 1;
  if (input.keys.has("ArrowRight")) dirX += 1;
  const targetVelX = dirX * conf.maxLateralSpeed;
  const isAccelerating = (dirX !== 0 && Math.sign(dirX) === Math.sign(ship.state.velX));
  const rate = isAccelerating ? conf.lateralAccel : conf.lateralFriction;
  const alpha = 1.0 - Math.exp(-rate * dt);
  ship.state.velX += (targetVelX - ship.state.velX) * alpha;
  // --- 3. BOUNDARY REPULSION FORCE (The "Invisible Wall") ---
  // The corridor is centered at World X = 0.
  // ship.state.cursorX is in SCREEN pixels relative to center.
  // We need to check the actual world position for the logic, or map cursor to world.
  // For simplicity in this demo, 'cursorX' is the driver.
  // Let's assume Screen Center (cx) = World X 0.
  const distFromCenter = ship.state.cursorX - cx;
  const absDist = Math.abs(distFromCenter);
  const boundaryEdge = conf.boundaryEdge || 550;
  // If we are past the safe edge
  if (absDist > boundaryEdge) {
    const penetration = absDist - boundaryEdge;
    // Exponential force: Increases rapidly the further you go
    const repulsion = Math.exp(penetration * 0.02) * (conf.boundaryStrength || 15.0);
    // Direction is opposite to current side
    const forceDir = (distFromCenter > 0) ? -1 : 1;
    // Apply to velocity
    ship.state.velX += repulsion * forceDir * dt;
  }
  // Apply Velocity to Position
  ship.state.cursorX += ship.state.velX * dt;
  // Vertical Clamp
  const minY = by - ship.state.boxHeight;
  const maxY = by;
  ship.state.cursorY = Math.max(minY, Math.min(maxY, ship.state.cursorY));
  // --- 4. RAYCAST & UPDATE ---
  ray.setFromCamera(
    new THREE.Vector2((ship.state.cursorX / w) * 2 - 1, -(ship.state.cursorY / h) * 2 + 1),
    camera
  );
  refPlane.constant = 0;
  if (ray.ray.intersectPlane(refPlane, _hit)) {
    const targetX = _hit.x;
    const currentZ = ship.mesh.position.z;
    // Physics
    const h1 = getSurfaceHeight(targetX, currentZ, time, activePlanets);
    const newZ = currentZ - ship.state.speedPx * dt;
    ship.mesh.position.set(targetX, h1 + conf.hoverOffset, newZ);
    ship.state.y = h1 + conf.hoverOffset;
  }
}
================================================================================

[-] This file: static/js/blackhole/main.js | Contents:
import { initThree } from "./three/three_boot.js";
import { createGrid, followGridToShip } from "./three/grid.js";
import { createShip } from "./three/ship.js";
import { Universe } from "./three/universe.js";
import { checkShipCollision } from "./three/asteroids.js";
import { updateShip } from "./input/ship_controls.js";
import { initOverlay } from "./phaser/phaser_overlay.js";
import { setupResize } from "./shared/resize.js";
import { updateChaseCamera } from "./input/camera_controls.js";
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js";
async function boot() {
  console.log("[BOOT] Fetching tuning...");
  const configRes = await fetch("/api/tuning");
  const config = await configRes.json();
  console.log("[BOOT] Tuning loaded:", config);
  // [FIX] Updated GUI to match new physics variables
  const gui = new GUI({ title: "Ship Controls" });
  const shipFolder = gui.addFolder("Movement Physics");
  shipFolder.add(config.ship, "baseSpeed", 0, 200).name("Fwd Speed");
  shipFolder.add(config.ship, "maxLateralSpeed", 50, 800).name("Lat Speed");
  shipFolder.add(config.ship, "lateralAccel", 1.0, 20.0).name("Lat Accel");
  shipFolder.add(config.ship, "lateralFriction", 0.5, 20.0).name("Inertia/Fric");
  // Replaced boxWidth with Boundary controls
  shipFolder.add(config.ship, "boundaryEdge", 300, 1000).name("Corridor Width");
  shipFolder.add(config.ship, "boundaryStrength", 0, 50).name("Wall Bounce");
  shipFolder.open();
  const universeFolder = gui.addFolder("Universe");
  universeFolder.add(config.universe, "maxPlanetsPerSector", 0, 5, 1).name("Planet Count");
  const canvas = document.getElementById("threeCanvas");
  const { renderer, scene, camera } = initThree(canvas);
  window.__camera = camera;
  const { mesh: gridMesh, uniforms } = createGrid(scene, config.grid);
  const ship = createShip(scene);
  const universe = new Universe(scene, uniforms, config);
  const phaserGame = initOverlay(ship);
  setupResize(renderer, camera, phaserGame);
  let last = performance.now();
  let isGameOver = false;
  function loop(t) {
    if (isGameOver) return;
    const dt = Math.min(0.033, (t - last) / 1000);
    last = t;
    uniforms.uTime.value += dt;
    const globalTime = uniforms.uTime.value;
    updateShip(ship, camera, renderer, dt, globalTime, universe.activePlanets, config.ship);
    updateChaseCamera(camera, ship, dt);
    followGridToShip(gridMesh, ship.mesh);
    universe.update(ship.mesh, dt, globalTime);
    const allAsteroids = [];
    universe.activePlanets.forEach(p => {
        if (p.userData.asteroids) {
            allAsteroids.push(...p.userData.asteroids);
        }
    });
    if (checkShipCollision(ship, allAsteroids)) {
      triggerGameOver("Hull Critical: Asteroid Impact");
      return;
    }
    if (checkPlanetCollision(ship, universe.activePlanets)) {
      triggerGameOver("Atmospheric Entry Failed: Planet Collision");
      return;
    }
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  function checkPlanetCollision(ship, planets) {
    const shipPos = ship.mesh.position;
    const shipR = ship.radius * 0.8;
    for (const p of planets) {
      const distSq = shipPos.distanceToSquared(p.position);
      const r = p.geometry.parameters.radius + shipR;
      if (distSq < r * r) return true;
    }
    return false;
  }
  function triggerGameOver(reason) {
    console.log("[GAME OVER]", reason);
    isGameOver = true;
    if (phaserGame && phaserGame.showGameOver) {
      phaserGame.showGameOver(reason);
    }
  }
  requestAnimationFrame(loop);
  console.log("[BOOT] main loop started");
}
boot();
================================================================================

[-] This file: static/js/blackhole/phaser/phaser_overlay.js | Contents:
export function initOverlay(ship) {
  let marker, box, gameOverText, reasonText;
  const game = new Phaser.Game({
    type: Phaser.WEBGL,
    parent: "phaserMount",
    width: innerWidth,
    height: innerHeight,
    transparent: true, // Crucial for overlay
    scale: { mode: Phaser.Scale.RESIZE },
    scene: {
      create() {
        // --- HUD ---
        marker = this.add.circle(0, 0, 5, 0xffffff).setDepth(10);
        box = this.add.graphics().setDepth(9);
        this.add.text(
          14, 12,
          "Arrow keys: ship (bottom box)\nAvoid orbiting asteroids\nAvoid Planets",
          { fontSize: "14px", color: "#fff", stroke: "#000", strokeThickness: 2 }
        );
        // --- Game Over Screens (Hidden by default) ---
        gameOverText = this.add.text(innerWidth / 2, innerHeight / 2 - 20, "GAME OVER", {
          fontSize: "64px",
          color: "#ff3333",
          fontStyle: "bold",
          stroke: "#000",
          strokeThickness: 6
        }).setOrigin(0.5).setVisible(false).setDepth(20);
        reasonText = this.add.text(innerWidth / 2, innerHeight / 2 + 40, "", {
          fontSize: "24px",
          color: "#ffffff",
          stroke: "#000",
          strokeThickness: 4
        }).setOrigin(0.5).setVisible(false).setDepth(20);
        // --- Expose function to Main Loop ---
        game.showGameOver = (reason) => {
          marker.setVisible(false);
          box.setVisible(false);
          gameOverText.setVisible(true);
          reasonText.setText(reason + "\nReload to Restart").setVisible(true);
          // Simple bounce animation
          this.tweens.add({
            targets: [gameOverText, reasonText],
            scale: { from: 0.8, to: 1 },
            duration: 800,
            ease: 'Bounce.Out'
          });
        };
        console.log("[PHASER] overlay ready");
      },
      update() {
        // Don't update HUD if game is over (optional preference)
        if (gameOverText.visible) return;
        const v = ship.mesh.position.clone().project(window.__camera);
        const w = window.innerWidth;
        const h = window.innerHeight;
        marker.setPosition((v.x * 0.5 + 0.5) * w, (-v.y * 0.5 + 0.5) * h);
        const cx = w / 2;
        const by = h - ship.state.boxBottom;
        // Red Control Box
        box.clear().lineStyle(2, 0xff0000, 0.6).strokeRect(
          cx - ship.state.boxWidth / 2,
          by - ship.state.boxHeight,
          ship.state.boxWidth,
          ship.state.boxHeight
        );
      }
    }
  });
  return game;
}
================================================================================

[-] This file: static/js/blackhole/shared/math.js | Contents:
export function rand(min, max) {
  return min + Math.random() * (max - min);
}
================================================================================

[-] This file: static/js/blackhole/shared/physics_height.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
// Must match grid_shader.js consts
const SOFTENING = 8.0;
const DEPTH_STRENGTH = 20.0;
// [TUNING] Slower, smoother liquid waves
const NOISE_AMP = 4.0;
const NOISE_FREQ = 0.015; // Lower frequency = Wider, gentler hills
const WAVE_SPEED = 0.2;   // Slower animation
// --- GLSL Hash / Noise Port ---
function fract(x) { return x - Math.floor(x); }
function hash(x, y) {
  const dot = x * 12.9898 + y * 78.233;
  const sin = Math.sin(dot);
  return fract(sin * 43758.5453);
}
function noise(x, y) {
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  const fx = fract(x);
  const fy = fract(y);
  // Cubic Hermite Smoothing
  const ux = fx * fx * (3.0 - 2.0 * fx);
  const uy = fy * fy * (3.0 - 2.0 * fy);
  const a = hash(ix, iy);
  const b = hash(ix + 1, iy);
  const c = hash(ix, iy + 1);
  const d = hash(ix + 1, iy + 1);
  return (a * (1 - ux) + b * ux) * (1 - uy) +
         (c * (1 - ux) + d * ux) * uy;
}
function fbm(x, y, t) {
  let total = 0.0;
  let amp = 1.0;
  let freq = NOISE_FREQ;
  // Animate the domain with time for liquid flow
  const tx = t * WAVE_SPEED;
  const ty = t * WAVE_SPEED * 0.5;
  // 3 Octaves
  for(let i = 0; i < 3; i++) {
    total += noise(x * freq + tx, y * freq + ty) * amp;
    freq *= 2.0;
    amp *= 0.5;
  }
  return total;
}
// --- Main Surface Function ---
export function getSurfaceHeight(x, z, t, planets) {
  // 1. Gravity Wells
  let w = 0.0;
  if (planets) {
    for (const p of planets) {
      const dx = x - p.position.x;
      const dz = z - p.position.z;
      // Simple inverse square approximation for depth
      w += p.userData.mass / (dx * dx + dz * dz + SOFTENING);
    }
  }
  // 2. Terrain Noise (Liquid)
  const terrain = fbm(x, z, t || 0) * NOISE_AMP;
  // 3. Combine
  return terrain - (w * DEPTH_STRENGTH);
}
================================================================================

[-] This file: static/js/blackhole/shared/resize.js | Contents:
export function setupResize(renderer, camera, phaserGame) {
  let queued = false;
  function doResize() {
    queued = false;
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    if (phaserGame?.scale?.resize) {
      try { phaserGame.scale.resize(w, h); }
      catch {}
    }
    console.log("[RESIZE]", w, h);
  }
  window.addEventListener("resize", () => {
    if (queued) return;
    queued = true;
    requestAnimationFrame(doResize);
  });
  doResize();
}
================================================================================

[-] This file: static/js/blackhole/three/asteroids.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { rand } from "../shared/math.js";
// Helper to noise-deform a sphere
function ruggedizeGeometry(geometry, amount) {
  const posAttribute = geometry.attributes.position;
  const vertex = new THREE.Vector3();
  for (let i = 0; i < posAttribute.count; i++) {
    vertex.fromBufferAttribute(posAttribute, i);
    // Displace along normal (which is just the normalized position for a sphere)
    // We use a simple random jitter here. For smoother rocks, we'd use Perlin noise,
    // but random jitter is usually enough for small asteroids.
    const deform = 1.0 + (Math.random() - 0.5) * amount;
    vertex.multiplyScalar(deform);
    posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
  }
  // Re-compute normals so lighting looks correct on the jagged surface
  geometry.computeVertexNormals();
  return geometry;
}
export function createAsteroidSystem(planetMesh, config) {
  // Config defaults
  const conf = config || {
    minCount: 4, maxCount: 8,
    minSize: 0.3, maxSize: 0.7,
    orbitDistanceMin: 1.5, orbitDistanceMax: 4.0,
    orbitSpeedMin: 0.2, orbitSpeedMax: 0.8,
    ruggedness: 0.2
  };
  const asteroids = [];
  const count = Math.floor(rand(conf.minCount, conf.maxCount));
  // 1. Define the Orbit Ring (A spline concept)
  // We want a ring around the equator (XZ plane relative to planet).
  // We don't need a visible line, just the math.
  for (let i = 0; i < count; i++) {
    // Randomize size
    const r = rand(conf.minSize, conf.maxSize);
    // Create Geometry
    let geo = new THREE.SphereGeometry(r, 7, 6); // Low poly for jagged look
    ruggedizeGeometry(geo, conf.ruggedness);
    const mat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.9,
        flatShading: true // Low poly look
    });
    const mesh = new THREE.Mesh(geo, mat);
    // 2. Setup Orbit Logic
    // Distance from planet center
    const planetRadius = planetMesh.geometry.parameters.radius;
    const dist = planetRadius + rand(conf.orbitDistanceMin, conf.orbitDistanceMax);
    // Start Angle
    const angle = Math.random() * Math.PI * 2;
    // Orbit Speed (Radians per second)
    const speed = rand(conf.orbitSpeedMin, conf.orbitSpeedMax) * (Math.random() < 0.5 ? 1 : -1);
    // Initial position (Local to planet)
    mesh.position.set(Math.cos(angle) * dist, rand(-0.5, 0.5), Math.sin(angle) * dist);
    // Add to Planet (So it moves with it)
    planetMesh.add(mesh);
    asteroids.push({
      mesh,
      orbitRadius: dist,
      angle: angle,
      speed: speed,
      rotationAxis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(),
      rotationSpeed: rand(0.5, conf.selfRotationSpeed),
      r: r // Collision radius
    });
  }
  return asteroids;
}
export function updateAsteroids(planetMesh, dt) {
  // We stored the asteroid data on the planetMesh.userData for convenience
  const data = planetMesh.userData.asteroids;
  if (!data) return;
  data.forEach(a => {
    // 1. Orbit Update (Smooth circular motion)
    a.angle += a.speed * dt;
    // Update local position relative to planet
    // This creates a perfect ring orbit that follows the planet smoothly
    a.mesh.position.x = Math.cos(a.angle) * a.orbitRadius;
    a.mesh.position.z = Math.sin(a.angle) * a.orbitRadius;
    // 2. Self Rotation (Tumbling)
    a.mesh.rotateOnAxis(a.rotationAxis, a.rotationSpeed * dt);
  });
}
// Global collision check (World Space)
export function checkShipCollision(ship, allAsteroids) {
  const shipPos = ship.mesh.position;
  const worldPos = new THREE.Vector3();
  for (const a of allAsteroids) {
    // Get asteroid real world position
    a.mesh.getWorldPosition(worldPos);
    const dx = worldPos.x - shipPos.x;
    const dz = worldPos.z - shipPos.z;
    // Simple sphere collision
    const rr = (ship.radius + a.r) * (ship.radius + a.r);
    // Optimistic height check first
    if (Math.abs(worldPos.y - shipPos.y) < 3.0) {
        if (dx * dx + dz * dz < rr) return true;
    }
  }
  return false;
}
================================================================================

[-] This file: static/js/blackhole/three/grid.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { makeGridMaterial } from "./grid_shader.js";
export function createGrid(scene) {
  const { material, uniforms } = makeGridMaterial(THREE);
  // Moderate size plane: constant memory.
  // Pattern is infinite due to world-based shader.
  const geo = new THREE.PlaneGeometry(180, 180, 240, 240);
  geo.rotateX(-Math.PI / 2);
  const mesh = new THREE.Mesh(geo, material);
  mesh.position.set(0, 0, 0);
  scene.add(mesh);
  return { mesh, uniforms };
}
export function followGridToShip(gridMesh, shipMesh) {
  // Keep grid centered under ship to avoid seeing edges
  gridMesh.position.x = shipMesh.position.x;
  gridMesh.position.z = shipMesh.position.z;
}
================================================================================

[-] This file: static/js/blackhole/three/grid_shader.js | Contents:
export const MAX_PLANETS = 8;
export function makeGridMaterial(THREE) {
  const uniforms = {
    uTime: { value: 0 },
    uGridScale: { value: 0.35 },
    uLineWidth: { value: 1.5 },
    uSoftening: { value: 8.0 },
    uDepth: { value: 20.0 },
    uFlowSpeed: { value: 2.0 },
    uFlowStrength: { value: 1.0 },
    uPlanetCount: { value: 0 },
    uPlanetPos: {
      value: Array.from({ length: MAX_PLANETS }, () => new THREE.Vector3(9999, 0, 9999))
    },
    uPlanetMass: { value: new Array(MAX_PLANETS).fill(0) },
    // Fog Uniforms
    ...THREE.UniformsLib.fog
  };
  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      uniform float uTime;
      uniform float uSoftening;
      uniform float uDepth;
      uniform int uPlanetCount;
      uniform vec3 uPlanetPos[${MAX_PLANETS}];
      uniform float uPlanetMass[${MAX_PLANETS}];
      varying vec2 vWorldXZ;
      varying float vWell;
      #include <fog_pars_vertex>
      float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
      float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                   mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
      }
      float fbm(vec2 p, float t) {
        float total = 0.0; float amp = 1.0; float freq = 0.03;
        vec2 shift = vec2(t * 0.5, t * 0.25);
        for(int i = 0; i < 3; i++) {
            total += noise(p * freq + shift) * amp;
            freq *= 2.0; amp *= 0.5;
        }
        return total;
      }
      float well(vec2 d, float m) { return m / (dot(d,d) + uSoftening); }
      void main() {
        vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        float w = 0.0;
        for (int i = 0; i < ${MAX_PLANETS}; i++) {
          if (i >= uPlanetCount) break;
          w += well(worldPos.xz - uPlanetPos[i].xz, uPlanetMass[i]);
        }
        float terrain = fbm(worldPos.xz, uTime) * 4.0;
        vec3 p = position;
        p.y -= uDepth * w;
        p.y += terrain;
        vWorldXZ = worldPos.xz;
        vWell = w;
        // [FIX] Define mvPosition explicitly for Fog
        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        #include <fog_vertex>
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform float uGridScale;
      uniform float uLineWidth;
      uniform float uSoftening;
      uniform float uFlowSpeed;
      uniform float uFlowStrength;
      uniform int uPlanetCount;
      uniform vec3 uPlanetPos[${MAX_PLANETS}];
      uniform float uPlanetMass[${MAX_PLANETS}];
      varying vec2 vWorldXZ;
      varying float vWell;
      #include <fog_pars_fragment>
      float gridLines(vec2 p) {
        vec2 g = p * uGridScale;
        vec2 a = abs(fract(g - 0.5) - 0.5) / fwidth(g);
        float line = 1.0 - min(min(a.x, a.y), 1.0);
        return smoothstep(0.0, 1.0, line * uLineWidth);
      }
      void main() {
        vec2 flow = vec2(0.0);
        for (int i = 0; i < ${MAX_PLANETS}; i++) {
          if (i >= uPlanetCount) break;
          vec2 d = uPlanetPos[i].xz - vWorldXZ;
          float r2 = dot(d,d) + uSoftening;
          vec2 radial = normalize(d + 1e-6);
          vec2 tangent = vec2(-radial.y, radial.x);
          flow += (radial * 0.5 + tangent * 1.5) * (uPlanetMass[i] / r2);
        }
        vec2 baseRiver = vec2(0.0, 1.0);
        vec2 finalFlow = baseRiver * 0.2 + flow * uFlowStrength;
        vec2 sampleXZ = vWorldXZ - finalFlow * (uTime * uFlowSpeed);
        float line = gridLines(sampleXZ);
        float glow = clamp(vWell * 8.0, 0.0, 0.8);
        vec3 col = vec3(line);
        col += glow * vec3(0.6, 0.8, 1.0);
        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 0.6);
        #include <fog_fragment>
      }
    `,
    transparent: true,
    depthWrite: false,
    depthTest: true,
    fog: true
  });
  return { material, uniforms };
}
================================================================================

[-] This file: static/js/blackhole/three/planets.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
// Pure factory: No scene adding, just mesh creation
export function createPlanetMesh(data) {
  const isBlackHole = data.type === "blackhole";
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(data.r, 24, 18),
    new THREE.MeshStandardMaterial({
      color: isBlackHole
        ? 0x050508
        : new THREE.Color().setHSL(data.colorHue, 0.6, 0.55),
      roughness: isBlackHole ? 0.25 : 0.55,
      metalness: 0.0,
      emissive: isBlackHole ? 0x110022 : 0x000000,
    })
  );
  return mesh;
}
================================================================================

[-] This file: static/js/blackhole/three/ship.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
export function createShip(scene) {
  const mesh = new THREE.Mesh(
    new THREE.ConeGeometry(0.65, 1.6, 4, 1),
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  // Rotate to point forward (-Z)
  mesh.rotation.y = Math.PI / 4;
  mesh.position.set(0, 3, 0);
  scene.add(mesh);
  return {
    mesh,
    radius: 0.55,
    state: {
      y: 3,
      speedPx: 140, // Reduced from 280 for slower movement
      boxWidth: 360,
      boxHeight: 210,
      boxBottom: 70
    }
  };
}
================================================================================

[-] This file: static/js/blackhole/three/three_boot.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
export function initThree(canvas) {
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 1);
  const scene = new THREE.Scene();
  // [NEW] Fog for smooth fade in.
  // Color 0x000000 (Black).
  // Start: 120 (Just beyond the ship), End: 450 (Fade out completely)
  scene.fog = new THREE.Fog(0x000000, 120, 450);
  // [NEW] Increased Far Plane to 6000 to prevent clipping before fog ends
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 6000);
  camera.rotation.order = "YXZ";
  resetCameraSym(camera);
  scene.add(new THREE.HemisphereLight(0xffffff, 0x101018, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(20, 40, 10);
  scene.add(dir);
  return { renderer, scene, camera };
}
export function resetCameraSym(camera) {
  camera.position.set(0, 13.5, 27.5);
  camera.lookAt(0, 0, 0);
}
================================================================================

[-] This file: static/js/blackhole/three/universe.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { createPlanetMesh } from "./planets.js";
import { rand } from "../shared/math.js";
import { createAsteroidSystem, updateAsteroids } from "./asteroids.js";
const MAX_SHADER_PLANETS = 8;
export class Universe {
  constructor(scene, uniforms, config) {
    this.scene = scene;
    this.uniforms = uniforms;
    this.config = config; // Tuning data
    this.sectorData = new Map();
    this.sectorMeshes = new Map();
    this.pendingKeys = new Set();
    // We track the 'row' (Z index) the ship is currently in
    this.currentRowZ = -999999;
    this.shipPos = new THREE.Vector3();
    this.activePlanets = [];
  }
  update(shipMesh, dt, time) {
    this.shipPos.copy(shipMesh.position);
    // Calculate which Z-Row the ship is in
    const sz = Math.floor(shipMesh.position.z / this.config.universe.sectorSize);
    // If we entered a new row, update the corridor
    if (sz !== this.currentRowZ) {
      this.currentRowZ = sz;
      this.updateCorridor(sz);
    }
    // Update Asteroids on active planets
    this.activePlanets.forEach(p => {
        updateAsteroids(p, dt);
    });
    this.updateShaderGravity();
  }
  async updateCorridor(currentZ) {
    const keysNeeded = [];
    // [LOGIC] 3-Lane Corridor
    // We always want sectors x=[-1, 0, 1] relative to the track center.
    // We want the current row, and 2 rows ahead for smooth scrolling.
    const forwardView = 2;
    for (let z = currentZ; z <= currentZ + forwardView; z++) {
        for (let x = -1; x <= 1; x++) {
            keysNeeded.push(`${x}:${z}`);
        }
    }
    // 1. Cleanup: Remove any sectors NOT in our needed list (Behind us or too far ahead)
    // This handles the "delete from memory as soon as it is behind us" requirement.
    for (const [key, meshes] of this.sectorMeshes) {
      if (!keysNeeded.includes(key)) {
        meshes.forEach(m => {
            this.scene.remove(m);
            if(m.geometry) m.geometry.dispose();
            if(m.material) m.material.dispose();
            m.userData.asteroids = null;
        });
        this.sectorMeshes.delete(key);
        // We can optionally keep the data in 'sectorData' if we want to revisit,
        // but for a scrolling shooter, we can probably let it go or keep it cached.
      }
    }
    // 2. Fetch/Generate: Load missing sectors
    const keysToFetch = keysNeeded.filter(k => !this.sectorData.has(k) && !this.pendingKeys.has(k));
    if (keysToFetch.length > 0) {
      await this.fetchSectors(keysToFetch);
    }
    // 3. Build: Ensure meshes exist for data we have
    keysNeeded.forEach(key => {
      if (this.sectorData.has(key) && !this.sectorMeshes.has(key)) {
        this.buildSector(key);
      }
    });
  }
  async fetchSectors(keys) {
    keys.forEach(k => this.pendingKeys.add(k));
    try {
      const params = new URLSearchParams({ keys: keys.join(",") });
      const res = await fetch(`/api/universe/load?${params}`);
      const data = await res.json();
      const newSectors = {};
      let hasNewData = false;
      keys.forEach(key => {
        if (data[key]) {
          this.sectorData.set(key, data[key]);
        } else {
          const generated = this.generateSector(key);
          this.sectorData.set(key, generated);
          newSectors[key] = generated;
          hasNewData = true;
        }
        this.pendingKeys.delete(key);
      });
      if (hasNewData) {
        fetch("/api/universe/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(newSectors)
        }).catch(e => console.error("Save failed", e));
      }
    } catch (e) {
      console.error("Universe fetch error:", e);
      keys.forEach(k => this.pendingKeys.delete(k));
    }
  }
  generateSector(key) {
    const uConf = this.config.universe;
    const [sx, sz] = key.split(":").map(Number);
    // Always Safe Zone at very start
    if (sx === 0 && sz === 0) return [];
    if (Math.random() < uConf.voidChance) return [];
    const planets = [];
    const count = Math.floor(rand(1, uConf.maxPlanetsPerSector));
    for (let i = 0; i < count; i++) {
      const isBlackHole = Math.random() < uConf.blackHoleChance;
      const r = isBlackHole ? rand(20, 30) : rand(12, 25);
      // Random position within the sector
      // Sector size is typically 500.
      // We want to fill the lane but keep it somewhat centered in its tile.
      const margin = uConf.sectorSize * 0.1;
      const effectiveSize = uConf.sectorSize * 0.8;
      const lx = (Math.random() * effectiveSize) - (effectiveSize / 2);
      const lz = (Math.random() * effectiveSize) - (effectiveSize / 2);
      const mass = isBlackHole ? r * r * 1.5 : r * 4.0;
      planets.push({
        x: sx * uConf.sectorSize + lx,
        y: rand(-5, 5),
        z: sz * uConf.sectorSize + lz,
        r: r,
        mass: mass,
        type: isBlackHole ? "blackhole" : "planet",
        colorHue: Math.random()
      });
    }
    return planets;
  }
  buildSector(key) {
    const data = this.sectorData.get(key);
    const meshes = [];
    data.forEach(pData => {
      const mesh = createPlanetMesh(pData);
      mesh.position.set(pData.x, pData.y, pData.z);
      if (!pData.isBlackHole && pData.type !== 'blackhole') {
        const asteroidConfig = {
            ...this.config.asteroids,
            minCount: 1,
            maxCount: 3,
            orbitDistanceMin: 1.2,
            orbitDistanceMax: 2.0,
            minSize: 0.8,
            maxSize: 1.5
        };
        const asteroids = createAsteroidSystem(mesh, asteroidConfig);
        mesh.userData.asteroids = asteroids;
      }
      this.scene.add(mesh);
      mesh.userData = { ...mesh.userData, ...pData };
      meshes.push(mesh);
    });
    this.sectorMeshes.set(key, meshes);
  }
  updateShaderGravity() {
    let allMeshes = [];
    for (const meshes of this.sectorMeshes.values()) {
      allMeshes = allMeshes.concat(meshes);
    }
    allMeshes.sort((a, b) => {
      const d1 = a.position.distanceToSquared(this.shipPos);
      const d2 = b.position.distanceToSquared(this.shipPos);
      return d1 - d2;
    });
    const closest = allMeshes.slice(0, MAX_SHADER_PLANETS);
    this.activePlanets = closest;
    this.uniforms.uPlanetCount.value = closest.length;
    for (let i = 0; i < MAX_SHADER_PLANETS; i++) {
      if (i < closest.length) {
        this.uniforms.uPlanetPos.value[i].copy(closest[i].position);
        this.uniforms.uPlanetMass.value[i] = closest[i].userData.mass;
      } else {
        this.uniforms.uPlanetPos.value[i].set(99999, 99999, 99999);
        this.uniforms.uPlanetMass.value[i] = 0;
      }
    }
  }
}
================================================================================
