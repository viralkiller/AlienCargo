Aggregated on: 2025-12-29 15:53:25
================================================================================
Project Directory Tree:
/
├── data
│   └── universe.json
├── static
│   ├── images
│   │   └── logo.png
│   ├── js
│   │   └── blackhole
│   │       ├── input
│   │       │   ├── camera_controls.js
│   │       │   ├── input_state.js
│   │       │   └── ship_controls.js
│   │       ├── phaser
│   │       │   └── phaser_overlay.js
│   │       ├── shared
│   │       │   ├── math.js
│   │       │   └── resize.js
│   │       ├── three
│   │       │   ├── asteroids.js
│   │       │   ├── grid.js
│   │       │   ├── grid_shader.js
│   │       │   ├── planets.js
│   │       │   ├── ship.js
│   │       │   ├── three_boot.js
│   │       │   └── universe.js
│   │       └── main.js
│   ├── panoramas
│   └── sounds
│       └── bass_rumble.mp3
├── templates
│   └── index.html
├── .bashrc
├── .gitconfig
├── .gitignore
├── .profile
├── .pythonstartup.py
├── .vimrc
├── _Review_Functions.py
├── flask_app.py
├── project_directory_full_code_1.txt
└── README.txt

12 directories, 28 files
================================================================================

[-] This file: .pythonstartup.py | Contents:
import rlcompleter
import readline
readline.parse_and_bind("tab: complete")
================================================================================

[-] This file: flask_app.py | Contents:
# flask_app.py
import logging
import json
import os
from pathlib import Path
from flask import Flask, render_template, request, jsonify
# -----------------------------
# Config
# -----------------------------
BASE_DIR = Path(__file__).resolve().parent
DATA_DIR = BASE_DIR / "data"
UNIVERSE_FILE = DATA_DIR / "universe.json"
# Ensure data directory exists
os.makedirs(DATA_DIR, exist_ok=True)
# -----------------------------
# Logging
# -----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
logger = logging.getLogger("blackhole")
# -----------------------------
# App setup
# -----------------------------
app = Flask(__name__)
# -----------------------------
# Data Persistence Helpers
# -----------------------------
def load_universe_data():
    """Loads the entire universe dictionary from JSON."""
    if not UNIVERSE_FILE.exists():
        return {}
    try:
        with open(UNIVERSE_FILE, "r") as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Failed to load universe data: {e}")
        return {}
def save_universe_data(new_data):
    """Merges new sector data into the existing JSON file."""
    try:
        # Load existing first to merge
        current = load_universe_data()
        current.update(new_data)
        with open(UNIVERSE_FILE, "w") as f:
            json.dump(current, f, indent=2)
    except Exception as e:
        logger.error(f"Failed to save universe data: {e}")
# -----------------------------
# Routes
# -----------------------------
@app.get("/")
def index():
    logger.info("UI: render index")
    return render_template("index.html")
@app.get("/api/universe/load")
def load_sectors():
    """
    Returns specific sectors requested via query param ?keys=1:2,1:3
    """
    keys = request.args.get("keys")
    all_data = load_universe_data()
    if not keys:
        # If no keys specified, return everything (useful for debug, risky if huge)
        return jsonify(all_data)
    requested_keys = keys.split(",")
    result = {k: all_data[k] for k in requested_keys if k in all_data}
    return jsonify(result)
@app.post("/api/universe/save")
def save_sector():
    """Receives a dictionary of sectors -> planet data and saves them."""
    data = request.json
    save_universe_data(data)
    return jsonify({"status": "ok"})
# -----------------------------
# Local dev entrypoint
# -----------------------------
if __name__ == "__main__":
    logger.info("Starting dev server at http://127.0.0.1:5000")
    app.run(debug=True, host="127.0.0.1", port=5000)
================================================================================

[-] This file: static/js/blackhole/input/camera_controls.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
const _desiredPos = new THREE.Vector3();
const _lookAt = new THREE.Vector3();
const _forward = new THREE.Vector3(0, 0, -1);
export function updateChaseCamera(camera, ship, dt) {
  // Ship forward from its yaw
  const shipYaw = ship.mesh.rotation.y - Math.PI / 4;
  const shipForward = _forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), shipYaw);
  // Camera offset behind/above ship in WORLD space
  const camHeight = 13.5;
  const camBack = 27.5;
  // Keep symmetrical: behind is +Z when ship forward is -Z
  _desiredPos.set(
    ship.mesh.position.x,
    ship.mesh.position.y + camHeight,
    ship.mesh.position.z + camBack
  );
  // Look ahead so ship sits lower
  // FIX: Increased lookAhead from 12.0 to 100.0.
  // This tilts the camera up, pushing the ship's visual position down to the
  // bottom of the screen where the control box is located.
  // This aligns the "neutral" cursor position with the ship's actual position,
  // preventing the infinite backward drift loop.
  const lookAhead = 100.0;
  _lookAt.copy(ship.mesh.position).addScaledVector(shipForward, lookAhead);
  // Smooth follow (stable + nice)
  const follow = 1.0 - Math.pow(0.001, dt); // dt-correct smoothing
  camera.position.lerp(_desiredPos, follow);
  camera.lookAt(_lookAt);
  // Debug log occasionally (not every frame)
  // You can uncomment if needed:
  // if (Math.random() < 0.01) console.log("[CAM][CHASE]", camera.position.toArray().map(n=>n.toFixed(2)).join(","));
}
================================================================================

[-] This file: static/js/blackhole/input/input_state.js | Contents:
export const input = {
  keys: new Set(),
  dragging: false,
  yaw: 0,
  pitch: 0
};
window.addEventListener("keydown", e => input.keys.add(e.code));
window.addEventListener("keyup", e => input.keys.delete(e.code));
================================================================================

[-] This file: static/js/blackhole/input/ship_controls.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { input } from "./input_state.js";
const ray = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
const _hit = new THREE.Vector3();
export function updateShip(ship, camera, renderer, dt) {
  const w = renderer.domElement.clientWidth;
  const h = renderer.domElement.clientHeight;
  // Bottom control box anchor (screen space)
  const cx = w / 2;
  const by = h - ship.state.boxBottom;
  // Persistent cursor inside box (screen space)
  if (ship.state.cursorX === undefined) ship.state.cursorX = cx;
  if (ship.state.cursorY === undefined) ship.state.cursorY = by - ship.state.boxHeight * 0.35;
  let dx = 0;
  let dy = 0;
  if (input.keys.has("ArrowLeft")) dx -= 1;
  if (input.keys.has("ArrowRight")) dx += 1;
  // IMPORTANT: Up should move the cursor UP (smaller sy) => forward in your chase view
  if (input.keys.has("ArrowUp")) dy -= 1;
  if (input.keys.has("ArrowDown")) dy += 1;
  if (!dx && !dy) return;
  // Normalize diagonal
  const len = Math.hypot(dx, dy) || 1;
  dx /= len;
  dy /= len;
  // Move cursor inside the box (accumulative!)
  const pxPerSec = ship.state.speedPx; // treat speedPx as cursor speed too
  ship.state.cursorX += dx * pxPerSec * dt;
  ship.state.cursorY += dy * pxPerSec * dt;
  // Clamp cursor to the red box
  const minX = cx - ship.state.boxWidth / 2;
  const maxX = cx + ship.state.boxWidth / 2;
  const minY = by - ship.state.boxHeight;
  const maxY = by;
  ship.state.cursorX = Math.max(minX, Math.min(maxX, ship.state.cursorX));
  ship.state.cursorY = Math.max(minY, Math.min(maxY, ship.state.cursorY));
  // Also clamp to window bounds (safety)
  ship.state.cursorX = Math.max(0, Math.min(w, ship.state.cursorX));
  ship.state.cursorY = Math.max(0, Math.min(h, ship.state.cursorY));
  // Debug (throttle a bit)
  if (Math.random() < 0.05) {
    console.log("[SHIP][CURSOR]", {
      dx: dx.toFixed(2),
      dy: dy.toFixed(2),
      cursorX: ship.state.cursorX.toFixed(1),
      cursorY: ship.state.cursorY.toFixed(1),
    });
  }
  // Screen -> ray -> plane hit
  ray.setFromCamera(
    new THREE.Vector2((ship.state.cursorX / w) * 2 - 1, -(ship.state.cursorY / h) * 2 + 1),
    camera
  );
  plane.constant = -ship.state.y;
  if (ray.ray.intersectPlane(plane, _hit)) {
    ship.mesh.position.set(_hit.x, ship.state.y, _hit.z);
    if (Math.random() < 0.03) {
      console.log("[SHIP][HIT]", {
        x: _hit.x.toFixed(2),
        z: _hit.z.toFixed(2),
      });
    }
  } else {
    console.warn("[SHIP] ray-plane miss");
  }
}
================================================================================

[-] This file: static/js/blackhole/main.js | Contents:
import { initThree } from "./three/three_boot.js";
import { createGrid, followGridToShip } from "./three/grid.js";
import { createShip } from "./three/ship.js";
import { Universe } from "./three/universe.js";
import { spawnAsteroids, updateAsteroids, checkShipCollision } from "./three/asteroids.js";
import { updateShip } from "./input/ship_controls.js";
import { initOverlay } from "./phaser/phaser_overlay.js";
import { setupResize } from "./shared/resize.js";
import { updateChaseCamera } from "./input/camera_controls.js";
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
const canvas = document.getElementById("threeCanvas");
const { renderer, scene, camera } = initThree(canvas);
window.__camera = camera;
const { mesh: gridMesh, uniforms } = createGrid(scene);
const ship = createShip(scene);
// Initialize the Infinite Universe Manager
const universe = new Universe(scene, uniforms);
// Create a pool of asteroids.
// We pass a dummy list of planets initially because the Universe loads async.
// This ensures the asteroid meshes are created. We will re-bind them in the loop.
const dummyPlanet = {
    mesh: { position: new THREE.Vector3(), geometry: { parameters: { radius: 2 }}}
};
// Spawn 3 groups of asteroids based on dummy data to fill the pool
const asteroidPool = spawnAsteroids(scene, [dummyPlanet, dummyPlanet, dummyPlanet], ship.state.y);
const phaserGame = initOverlay(ship);
setupResize(renderer, camera, phaserGame);
let last = performance.now();
function loop(t) {
  const dt = Math.min(0.033, (t - last) / 1000);
  last = t;
  uniforms.uTime.value += dt;
  // Ship moves in its bottom box
  updateShip(ship, camera, renderer, dt);
  // Camera is locked to ship (chase)
  updateChaseCamera(camera, ship, dt);
  // Keep grid under ship (no edges, constant memory)
  followGridToShip(gridMesh, ship.mesh);
  // Universe Logic (Handles loading/unloading/rendering planets)
  universe.update(ship.mesh);
  // Asteroid Logic: Bind asteroids to currently active planets
  // This allows asteroids to reuse the pool and appear around whatever is close
  if (universe.activePlanets && universe.activePlanets.length > 0) {
    asteroidPool.forEach((a, i) => {
        // Distribute asteroids among the visible planets
        const p = universe.activePlanets[i % universe.activePlanets.length];
        // If the asteroid is extremely far from its assigned planet (e.g. planet unloaded),
        // snap it back to the new planet immediately
        const dx = a.mesh.position.x - p.position.x;
        const dz = a.mesh.position.z - p.position.z;
        if (dx*dx + dz*dz > 50000) {
             a.angle = Math.random() * Math.PI * 2; // Reset orbit angle
        }
        // Update the reference so updateAsteroids() calculates orbit around THIS planet
        a.planet = { mesh: p };
        // Update orbit radius based on the new planet's size
        a.orbit = p.userData.r + 3.0 + (i % 3);
    });
  }
  updateAsteroids(asteroidPool, dt);
  if (checkShipCollision(ship, asteroidPool)) {
    console.log("[COLLISION] ship hit asteroid");
  }
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
console.log("[BOOT] main loop started");
================================================================================

[-] This file: static/js/blackhole/phaser/phaser_overlay.js | Contents:
export function initOverlay(ship) {
  let marker, box;
  const game = new Phaser.Game({
    type: Phaser.WEBGL,
    parent: "phaserMount",
    width: innerWidth,
    height: innerHeight,
    transparent: true,
    scale: { mode: Phaser.Scale.RESIZE },
    scene: {
      create() {
        marker = this.add.circle(0, 0, 5, 0xffffff).setDepth(10);
        box = this.add.graphics().setDepth(9);
        this.add.text(
          14, 12,
          "Arrow keys: ship (bottom box)\nAvoid orbiting asteroids\nCamera follows ship",
          { fontSize: "14px", color: "#fff" }
        );
        console.log("[PHASER] overlay ready");
      },
      update() {
        const v = ship.mesh.position.clone().project(window.__camera);
        const w = window.innerWidth;
        const h = window.innerHeight;
        marker.setPosition((v.x * 0.5 + 0.5) * w, (-v.y * 0.5 + 0.5) * h);
        const cx = w / 2;
        const by = h - ship.state.boxBottom;
        box.clear().lineStyle(2, 0xff0000, 0.6).strokeRect(
          cx - ship.state.boxWidth / 2,
          by - ship.state.boxHeight,
          ship.state.boxWidth,
          ship.state.boxHeight
        );
      }
    }
  });
  return game;
}
================================================================================

[-] This file: static/js/blackhole/shared/math.js | Contents:
export function rand(min, max) {
  return min + Math.random() * (max - min);
}
================================================================================

[-] This file: static/js/blackhole/shared/resize.js | Contents:
export function setupResize(renderer, camera, phaserGame) {
  let queued = false;
  function doResize() {
    queued = false;
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    if (phaserGame?.scale?.resize) {
      try { phaserGame.scale.resize(w, h); }
      catch {}
    }
    console.log("[RESIZE]", w, h);
  }
  window.addEventListener("resize", () => {
    if (queued) return;
    queued = true;
    requestAnimationFrame(doResize);
  });
  doResize();
}
================================================================================

[-] This file: static/js/blackhole/three/asteroids.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { rand } from "../shared/math.js";
export function spawnAsteroids(scene, planets, shipY) {
  const asteroids = [];
  planets.forEach((p) => {
    if (p.isBlackHole) return;
    const count = Math.floor(rand(4, 7));
    for (let i = 0; i < count; i++) {
      const r = rand(0.12, 0.28);
      const orbit = p.mesh.geometry.parameters.radius + rand(1.2, 3.6);
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(r, 12, 10),
        new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.9, metalness: 0.0 })
      );
      scene.add(mesh);
      asteroids.push({
        mesh,
        planet: p,
        angle: rand(0, Math.PI * 2),
        speed: rand(0.6, 1.8) * (Math.random() < 0.5 ? -1 : 1),
        orbit,
        r,
        y: shipY + rand(-0.2, 0.2),
      });
    }
  });
  console.log("[ASTEROIDS] spawned:", asteroids.length);
  return asteroids;
}
export function updateAsteroids(asteroids, dt) {
  asteroids.forEach((a) => {
    a.angle += a.speed * dt;
    a.mesh.position.set(
      a.planet.mesh.position.x + Math.cos(a.angle) * a.orbit,
      a.y,
      a.planet.mesh.position.z + Math.sin(a.angle) * a.orbit
    );
  });
}
export function checkShipCollision(ship, asteroids) {
  for (const a of asteroids) {
    const dx = a.mesh.position.x - ship.mesh.position.x;
    const dz = a.mesh.position.z - ship.mesh.position.z;
    const rr = (ship.radius + a.r) * (ship.radius + a.r);
    if (dx * dx + dz * dz < rr) return true;
  }
  return false;
}
================================================================================

[-] This file: static/js/blackhole/three/grid.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { makeGridMaterial } from "./grid_shader.js";
export function createGrid(scene) {
  const { material, uniforms } = makeGridMaterial(THREE);
  // Moderate size plane: constant memory.
  // Pattern is infinite due to world-based shader.
  const geo = new THREE.PlaneGeometry(180, 180, 240, 240);
  geo.rotateX(-Math.PI / 2);
  const mesh = new THREE.Mesh(geo, material);
  mesh.position.set(0, 0, 0);
  scene.add(mesh);
  return { mesh, uniforms };
}
export function followGridToShip(gridMesh, shipMesh) {
  // Keep grid centered under ship to avoid seeing edges
  gridMesh.position.x = shipMesh.position.x;
  gridMesh.position.z = shipMesh.position.z;
}
================================================================================

[-] This file: static/js/blackhole/three/grid_shader.js | Contents:
export const MAX_PLANETS = 8;
export function makeGridMaterial(THREE) {
  const uniforms = {
    uTime: { value: 0 },
    // Grid tuning
    uGridScale: { value: 0.35 },      // lines per world unit
    uLineWidth: { value: 1.25 },
    uSoftening: { value: 8.0 },
    uDepth: { value: 22.0 },
    // FLOW x16 (strong)
    uFlowSpeed: { value: 0.14 * 16.0 },
    uFlowStrength: { value: 0.018 * 16.0 },
    uPlanetCount: { value: 0 },
    uPlanetPos: {
      value: Array.from({ length: MAX_PLANETS }, () => new THREE.Vector3(9999, 0, 9999))
    },
    uPlanetMass: { value: new Array(MAX_PLANETS).fill(0) }
  };
  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      uniform float uTime;
      uniform float uSoftening;
      uniform float uDepth;
      uniform int uPlanetCount;
      uniform vec3 uPlanetPos[${MAX_PLANETS}];
      uniform float uPlanetMass[${MAX_PLANETS}];
      varying vec2 vWorldXZ;
      varying float vWell;
      // --- Noise Functions for Terrain ---
      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
      }
      // Simple value noise
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        // Hermite smoothing
        f = f * f * (3.0 - 2.0 * f);
        float a = hash(i + vec2(0.0, 0.0));
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
      }
      // Fractal Brownian Motion (Terrain layering)
      float fbm(vec2 p) {
        float total = 0.0;
        float amp = 1.0;
        float freq = 0.1;
        // 3 Octaves
        for(int i = 0; i < 3; i++) {
            total += noise(p * freq) * amp;
            freq *= 2.0;
            amp *= 0.5;
        }
        return total;
      }
      float well(vec2 d, float m) {
        return m / (dot(d,d) + uSoftening);
      }
      void main() {
        vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        // 1. Gravity Wells
        float w = 0.0;
        for (int i = 0; i < ${MAX_PLANETS}; i++) {
          if (i >= uPlanetCount) break;
          w += well(worldPos.xz - uPlanetPos[i].xz, uPlanetMass[i]);
        }
        // 2. Terrain Noise (Static in World Space)
        // Adjust frequency (0.15) for hill size and amplitude (4.0) for height
        float terrain = fbm(worldPos.xz * 0.15) * 4.0;
        // Apply Displacements
        vec3 p = position;
        // Push down for gravity, push up/down for terrain
        p.y -= uDepth * w;
        p.y += terrain;
        // Pass to fragment
        vWorldXZ = worldPos.xz;
        vWell = w;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform float uGridScale;
      uniform float uLineWidth;
      uniform float uSoftening;
      uniform float uFlowSpeed;
      uniform float uFlowStrength;
      uniform int uPlanetCount;
      uniform vec3 uPlanetPos[${MAX_PLANETS}];
      uniform float uPlanetMass[${MAX_PLANETS}];
      varying vec2 vWorldXZ;
      varying float vWell;
      float gridLines(vec2 p) {
        // p in world space * scale
        vec2 g = p * uGridScale;
        // Anti-aliased grid using fwidth
        vec2 a = abs(fract(g - 0.5) - 0.5) / fwidth(g);
        float line = 1.0 - min(min(a.x, a.y), 1.0);
        return smoothstep(0.0, 1.0, line * uLineWidth);
      }
      void main() {
        // Flow vector field (WORLD)
        vec2 flow = vec2(0.0);
        for (int i = 0; i < ${MAX_PLANETS}; i++) {
          if (i >= uPlanetCount) break;
          vec2 d = uPlanetPos[i].xz - vWorldXZ;
          float r2 = dot(d,d) + uSoftening;
          flow += normalize(d + 1e-6) * (uPlanetMass[i] / r2);
        }
        vec2 flowDir = normalize(flow + 1e-6);
        float flowMag = clamp(length(flow) * 0.08, 0.0, 1.0);
        // Advect the sample position (visual “grid streaming”)
        vec2 sampleXZ = vWorldXZ + flowDir * (uFlowStrength * flowMag) * (uTime * uFlowSpeed);
        float line = gridLines(sampleXZ);
        // Glow around curvature
        float glow = clamp(vWell * 12.0, 0.0, 0.55);
        vec3 col = vec3(line);
        col += glow * vec3(0.9, 0.9, 1.0);
        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
      }
    `,
    transparent: false,
    depthWrite: true,
    depthTest: true
  });
  return { material, uniforms };
}
================================================================================

[-] This file: static/js/blackhole/three/planets.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
// Pure factory: No scene adding, just mesh creation
export function createPlanetMesh(data) {
  const isBlackHole = data.type === "blackhole";
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(data.r, 24, 18),
    new THREE.MeshStandardMaterial({
      color: isBlackHole
        ? 0x050508
        : new THREE.Color().setHSL(data.colorHue, 0.6, 0.55),
      roughness: isBlackHole ? 0.25 : 0.55,
      metalness: 0.0,
      emissive: isBlackHole ? 0x110022 : 0x000000,
    })
  );
  return mesh;
}
================================================================================

[-] This file: static/js/blackhole/three/ship.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
export function createShip(scene) {
  const mesh = new THREE.Mesh(
    new THREE.ConeGeometry(0.65, 1.6, 4, 1),
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  // Rotate to point forward (-Z)
  mesh.rotation.y = Math.PI / 4;
  mesh.position.set(0, 3, 0);
  scene.add(mesh);
  return {
    mesh,
    radius: 0.55,
    state: {
      y: 3,
      speedPx: 140, // Reduced from 280 for slower movement
      boxWidth: 360,
      boxHeight: 210,
      boxBottom: 70
    }
  };
}
================================================================================

[-] This file: static/js/blackhole/three/three_boot.js | Contents:
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
export function initThree(canvas) {
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 1);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 5000);
  camera.rotation.order = "YXZ";
  resetCameraSym(camera);
  scene.add(new THREE.HemisphereLight(0xffffff, 0x101018, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(20, 40, 10);
  scene.add(dir);
  return { renderer, scene, camera };
}
export function resetCameraSym(camera) {
  camera.position.set(0, 13.5, 27.5);
  camera.lookAt(0, 0, 0);
}
================================================================================

[-] This file: static/js/blackhole/three/universe.js | Contents:
// static/js/blackhole/three/universe.js
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { createPlanetMesh } from "./planets.js";
import { rand } from "../shared/math.js";
// Size of one "sector" in world units
const SECTOR_SIZE = 250;
const MAX_SHADER_PLANETS = 8;
export class Universe {
  constructor(scene, uniforms) {
    this.scene = scene;
    this.uniforms = uniforms;
    // Key: "x:z" (sector coords), Value: Array of planet data objects
    this.sectorData = new Map();
    // Key: "x:z", Value: Array of THREE.Mesh objects
    this.sectorMeshes = new Map();
    // Set of keys currently queued for fetching/saving to prevent duplicate calls
    this.pendingKeys = new Set();
    this.currentSector = { x: 999999, z: 999999 };
    this.shipPos = new THREE.Vector3();
    // Public list of planets currently in the scene (sorted by distance)
    this.activePlanets = [];
  }
  update(shipMesh) {
    this.shipPos.copy(shipMesh.position);
    // 1. Calculate current sector index based on ship position
    const sx = Math.floor(shipMesh.position.x / SECTOR_SIZE);
    const sz = Math.floor(shipMesh.position.z / SECTOR_SIZE);
    // 2. If entered new sector, manage lifecycle (load new, unload old)
    if (sx !== this.currentSector.x || sz !== this.currentSector.z) {
      this.currentSector = { x: sx, z: sz };
      this.handleSectorChange(sx, sz);
    }
    // 3. Update Shader Uniforms (pass closest 8 planets to the grid shader)
    this.updateShaderGravity();
  }
  async handleSectorChange(cx, cz) {
    // Determine the 3x3 grid of sectors around the ship to keep loaded
    const keysNeeded = [];
    for (let x = cx - 1; x <= cx + 1; x++) {
      for (let z = cz - 1; z <= cz + 1; z++) {
        keysNeeded.push(`${x}:${z}`);
      }
    }
    // 1. Unload far sectors (cleanup memory)
    for (const [key, meshes] of this.sectorMeshes) {
      if (!keysNeeded.includes(key)) {
        meshes.forEach(m => {
            this.scene.remove(m);
            if(m.geometry) m.geometry.dispose();
            if(m.material) m.material.dispose();
        });
        this.sectorMeshes.delete(key);
      }
    }
    // 2. Identify missing data
    const keysToFetch = keysNeeded.filter(k => !this.sectorData.has(k) && !this.pendingKeys.has(k));
    if (keysToFetch.length > 0) {
      await this.fetchSectors(keysToFetch);
    }
    // 3. Instantiate meshes for data we have but haven't built yet
    keysNeeded.forEach(key => {
      if (this.sectorData.has(key) && !this.sectorMeshes.has(key)) {
        this.buildSector(key);
      }
    });
  }
  async fetchSectors(keys) {
    keys.forEach(k => this.pendingKeys.add(k));
    try {
      // Ask backend for these sectors
      const params = new URLSearchParams({ keys: keys.join(",") });
      const res = await fetch(`/api/universe/load?${params}`);
      const data = await res.json();
      const newSectors = {};
      let hasNewData = false;
      keys.forEach(key => {
        if (data[key]) {
          // Found in DB
          this.sectorData.set(key, data[key]);
        } else {
          // Not found -> Procedurally Generate
          const generated = this.generateSector(key);
          this.sectorData.set(key, generated);
          newSectors[key] = generated;
          hasNewData = true;
        }
        this.pendingKeys.delete(key);
      });
      // Save newly generated sectors back to DB
      if (hasNewData) {
        fetch("/api/universe/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(newSectors)
        }).catch(e => console.error("Save failed", e));
      }
    } catch (e) {
      console.error("Universe fetch error:", e);
      keys.forEach(k => this.pendingKeys.delete(k));
    }
  }
  generateSector(key) {
    const [sx, sz] = key.split(":").map(Number);
    const planets = [];
    // 10% chance for an empty void sector
    const isVoid = Math.random() < 0.1;
    if (isVoid) return [];
    // 1-3 planets per sector
    const count = Math.floor(rand(1, 4));
    for (let i = 0; i < count; i++) {
      // 5% chance for a black hole
      const isBlackHole = Math.random() < 0.05;
      const r = isBlackHole ? rand(1.5, 2.5) : rand(1.0, 3.0);
      // Position relative to sector center
      const lx = rand(-SECTOR_SIZE * 0.4, SECTOR_SIZE * 0.4);
      const lz = rand(-SECTOR_SIZE * 0.4, SECTOR_SIZE * 0.4);
      planets.push({
        x: sx * SECTOR_SIZE + lx,
        y: rand(0, 10), // variable height variation
        z: sz * SECTOR_SIZE + lz,
        r: r,
        mass: r * r * (isBlackHole ? 20 : 3), // Black holes are much heavier
        type: isBlackHole ? "blackhole" : "planet",
        colorHue: Math.random()
      });
    }
    return planets;
  }
  buildSector(key) {
    const data = this.sectorData.get(key);
    const meshes = [];
    data.forEach(pData => {
      const mesh = createPlanetMesh(pData);
      mesh.position.set(pData.x, pData.y, pData.z);
      this.scene.add(mesh);
      // Link data for logic
      mesh.userData = { ...pData };
      meshes.push(mesh);
    });
    this.sectorMeshes.set(key, meshes);
  }
  updateShaderGravity() {
    // Collect all active planets from loaded sectors
    let allMeshes = [];
    for (const meshes of this.sectorMeshes.values()) {
      allMeshes = allMeshes.concat(meshes);
    }
    // Sort by distance to ship
    allMeshes.sort((a, b) => {
      const d1 = a.position.distanceToSquared(this.shipPos);
      const d2 = b.position.distanceToSquared(this.shipPos);
      return d1 - d2;
    });
    // Pick top 8 for the shader
    const closest = allMeshes.slice(0, MAX_SHADER_PLANETS);
    this.activePlanets = closest;
    // Update Uniforms
    this.uniforms.uPlanetCount.value = closest.length;
    for (let i = 0; i < MAX_SHADER_PLANETS; i++) {
      if (i < closest.length) {
        this.uniforms.uPlanetPos.value[i].copy(closest[i].position);
        this.uniforms.uPlanetMass.value[i] = closest[i].userData.mass;
      } else {
        // Clear unused slots
        this.uniforms.uPlanetPos.value[i].set(99999, 99999, 99999);
        this.uniforms.uPlanetMass.value[i] = 0;
      }
    }
  }
}
================================================================================

[-] This file: templates/index.html | Contents:
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Black Hole – Hybrid 2.5D Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, Arial, sans-serif;
    }
    #wrap {
      position: relative;
      width: 100%;
      height: 100%;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    #threeCanvas { z-index: 0; }
    #phaserMount canvas {
      z-index: 1;
      background: transparent !important;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="threeCanvas"></canvas>
    <div id="phaserMount"></div>
  </div>
  <!-- Phaser -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <!-- Main entry -->
  <script type="module" src="/static/js/blackhole/main.js"></script>
</body>
</html>
================================================================================
